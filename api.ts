/**
 * Switch Database REST API
 * Switch API is the primary endpoint of data sevices and Switch DB's platform. You can do adding, editing, deleting or listing data works to your database with query operations by using this low-level API based on HTTP.
 *
 * OpenAPI spec version: 1.2.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://tr02.switchapi.com/';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AddResponse {
    'responseTime': number;
    'response': string;
    'listItemId': string;
}

export class Body {
    /**
    * List name.
    */
    'list': string;
    /**
    * Item count.
    */
    'count': number;
    /**
    * Page number.
    */
    'page': number;
    /**
    * Optional enumerator. You can assign the mode of implementation of where criterions by using AND and OR types under whereType parameter.
    */
    'whereType': string;
    'where': Array<WhereItem>;
    'order': ListOrder;
}

export class ListOrder {
    /**
    * Order types: ASC, DESC
    */
    'type': string;
    /**
    * Column name.
    */
    'by': string;
}

export class ModelError {
    'responseTime': number;
    'response': string;
    'errorMessage': string;
}

export class SetResponse {
    'responseTime': number;
    'response': string;
}

export class WhereItem {
    /**
    * You can explain the controls of more than one state with where. The controls of states: equal, notEqual, like, greaterThan, lessThan
    */
    'type': string;
    /**
    * Column name
    */
    'column': string;
    /**
    * Column value
    */
    'value': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AuthorizationApiApiKeys {
}

export class AuthorizationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthorizationApiApiKeys, value: string) {
        this.authentications[AuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Generate Access Token
     * For generating Access Token, you need API Key and API Secret parameters that are provided from the developer portal. At the request, API Key that will be sent by using header is generated as portal API Key and Signature parameter is generated as md5(APISecret + ExpireTimestamp) format. At Expire parameter, token&#39;s expire date and time information must be proper to ISO 8601 standarts and Unix Time format with msec information. 
     * @param aPIKey Your Switch API Key.
     * @param signature Signature parameter is generated as md5(APISecret + ExpireTimestamp) format.
     * @param expire Expire parameter, token&#39;s expire date and time information must be proper to ISO 8601 standarts and Unix Time format with msec information.
     */
    public tokenGet (aPIKey: string, signature: string, expire: number) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/Token';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'aPIKey' is not null or undefined
        if (aPIKey === null || aPIKey === undefined) {
            throw new Error('Required parameter aPIKey was null or undefined when calling tokenGet.');
        }

        // verify required parameter 'signature' is not null or undefined
        if (signature === null || signature === undefined) {
            throw new Error('Required parameter signature was null or undefined when calling tokenGet.');
        }

        // verify required parameter 'expire' is not null or undefined
        if (expire === null || expire === undefined) {
            throw new Error('Required parameter expire was null or undefined when calling tokenGet.');
        }

        headerParams['APIKey'] = aPIKey;

        headerParams['Signature'] = signature;

        headerParams['Expire'] = expire;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DBOperationsApiApiKeys {
}

export class DBOperationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DBOperationsApiApiKeys, value: string) {
        this.authentications[DBOperationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add is used for adding a data object to the list created at Switch DB.
     * You can choose the list that will be added tha data set to with List parameter that will be sent to Header. It&#39;s equal to INSERT query at the relational databases model. The data set that will be added to the database is transmited at request body. For versions upper than v1.2.1, if the data sent is an array, all items in the array are added one by one, so they are added as a whole. 
     * @param aPIKey Your Switch API Key.
     * @param accessToken Your Access Token.
     * @param list Your data list name.
     * @param body Your new value JSON.
     */
    public addPost (aPIKey: string, accessToken: string, list: string, body: string) : Promise<{ response: http.ClientResponse; body: AddResponse;  }> {
        const localVarPath = this.basePath + '/Add';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'aPIKey' is not null or undefined
        if (aPIKey === null || aPIKey === undefined) {
            throw new Error('Required parameter aPIKey was null or undefined when calling addPost.');
        }

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling addPost.');
        }

        // verify required parameter 'list' is not null or undefined
        if (list === null || list === undefined) {
            throw new Error('Required parameter list was null or undefined when calling addPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addPost.');
        }

        headerParams['APIKey'] = aPIKey;

        headerParams['AccessToken'] = accessToken;

        headerParams['List'] = list;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AddResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It&#39;s used for listing a data added before.
     * List parameter sent remarks the list that will be do listing work on at Header. It&#39;s equal to SELECT query at relational databases. 
     * @param aPIKey Your Switch API Key.
     * @param accessToken Your Access Token.
     * @param list Your data list name.
     * @param body Your Switch DB Query.
     */
    public listPost (aPIKey: string, accessToken: string, list: string, body: Body) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/List';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'aPIKey' is not null or undefined
        if (aPIKey === null || aPIKey === undefined) {
            throw new Error('Required parameter aPIKey was null or undefined when calling listPost.');
        }

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling listPost.');
        }

        // verify required parameter 'list' is not null or undefined
        if (list === null || list === undefined) {
            throw new Error('Required parameter list was null or undefined when calling listPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling listPost.');
        }

        headerParams['APIKey'] = aPIKey;

        headerParams['AccessToken'] = accessToken;

        headerParams['List'] = list;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It&#39;s used for deleting a data added before at Switch DB.
     * List parameter sent remarks the list that will be deleted data from at Header and ListItemId parameter remarks the ID consisted by Switch DB for the data that will be deleted. It&#39;s equal to DELETE query at relational databases. 
     * @param aPIKey Your Switch API Key.
     * @param accessToken Your Access Token.
     * @param list Your data list name.
     * @param listItemId Your list item id.
     */
    public setDelete (aPIKey: string, accessToken: string, list: string, listItemId: string) : Promise<{ response: http.ClientResponse; body: SetResponse;  }> {
        const localVarPath = this.basePath + '/Set';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'aPIKey' is not null or undefined
        if (aPIKey === null || aPIKey === undefined) {
            throw new Error('Required parameter aPIKey was null or undefined when calling setDelete.');
        }

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling setDelete.');
        }

        // verify required parameter 'list' is not null or undefined
        if (list === null || list === undefined) {
            throw new Error('Required parameter list was null or undefined when calling setDelete.');
        }

        // verify required parameter 'listItemId' is not null or undefined
        if (listItemId === null || listItemId === undefined) {
            throw new Error('Required parameter listItemId was null or undefined when calling setDelete.');
        }

        headerParams['APIKey'] = aPIKey;

        headerParams['AccessToken'] = accessToken;

        headerParams['List'] = list;

        headerParams['ListItemId'] = listItemId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SetResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It&#39;s used for updating a data object that is already added to Switch DB.
     * In order to UPDATE a object, Listname and ListItemId parameters should be sent in the Header of the REQUEST as \&quot;List\&quot;, \&quot;ListItemId\&quot;, respectively, as shown in the example below. It&#39;s equal to UPDATE query at relational databases. The data set that will be edited is transmited to the database at request body. 
     * @param aPIKey Your Switch API Key.
     * @param accessToken Your Access Token.
     * @param list Your data list name.
     * @param listItemId Your list item id.
     * @param body Your new value JSON.
     */
    public setPost (aPIKey: string, accessToken: string, list: string, listItemId: string, body: string) : Promise<{ response: http.ClientResponse; body: SetResponse;  }> {
        const localVarPath = this.basePath + '/Set';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'aPIKey' is not null or undefined
        if (aPIKey === null || aPIKey === undefined) {
            throw new Error('Required parameter aPIKey was null or undefined when calling setPost.');
        }

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling setPost.');
        }

        // verify required parameter 'list' is not null or undefined
        if (list === null || list === undefined) {
            throw new Error('Required parameter list was null or undefined when calling setPost.');
        }

        // verify required parameter 'listItemId' is not null or undefined
        if (listItemId === null || listItemId === undefined) {
            throw new Error('Required parameter listItemId was null or undefined when calling setPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setPost.');
        }

        headerParams['APIKey'] = aPIKey;

        headerParams['AccessToken'] = accessToken;

        headerParams['List'] = list;

        headerParams['ListItemId'] = listItemId;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SetResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
